Overview
========

``mrfmsim`` package was originally designed as a simulation package
for the MRFM experiment. For previous development, please see the
archived package 
`mrfmsim_archived <https://github.com/peterhs73/MrfmSim-archived>`__. 
The community's interest in the author's presentation at Nano-MRI:
at Nano-MRI: The next generation prompted the development of a
the package that includes more experiments from the MRFM community. 
The previous versions of MRFM uses an object-oriented design, which 
is restrictive and specific to the Marohn group. Since we developed
`mmodel <https://github.com/Marohn-Group/mmodel>`__ package as a
backend for ``mrfmsim``, allowing us to use directed acyclic 
graphs (DAG) to define experiments. Here we highlight the benefits
of using ``mmdoel`` as the backend.

Here we use a Cornell-style CERMIT ESR experiment as an example
(see ``mrfmsim_marohn`` for the explanation of the experiment).

The following code assumes the ``mrfmsim_marohn`` package is loaded::

    import mrfmsim
    mrfmsim.load_plugins()

Graph representation and metadata
---------------------------------

The graph representation of the experiment allows us to easily visualize the steps of the experiment. The metadata shows the signature, returns, description and more of the experiment.

To printout the metadata of the model::

    from mrfmsim.experiment import cermitesr
    
    >>> print(cermitesr)
    >>> CermitESR(B0, B1, cantilever, f_rf, grid, h, magnet, mw_x_0p, sample)
        returns: df_spin
        graph: cornell_esr_graph
        handler: MemHandler
        modifiers:
          - replace_component({'magnet': ['Bz_method', 'Bzxx_method'], 'sample': ['J',
          'Gamma', 'spin_density', 'temperature', 'dB_sat', 'dB_hom'], 'grid':
          ['grid_array', 'grid_shape', 'grid_step', 'grid_voxel', 'extend_grid_method'],
          'cantilever': ['dk_to_df_ac_cermit']})

        Simulates a Cornell-style frequency shift magnetic resonance force microscope
          experiment in which microwaves are applied for half a cantilever cyclic to
          saturate electron spin resonance in a bowl-shaped region swept out by the
          cantilever motion.

To draw the graph of the model::

    from mrfmsim.experiment import cermitesr
    cermitesr.draw()

.. image:: _static/cermitesr.pdf
    :width: 800px
    :align: center


Model Modification Post Definition
----------------------------------

Profiling
~~~~~~~~~

Use the "double_looped_cermitesr" model defined above, and we can
inspect the performance of each node::

    from mrfmsim.shortcut import modifier_shortcut
    from mrfsmim.modifier import profile_time

    
    print_shortcut(double_looped_cermitesr, ["B0", "f_rf", "df_spin"])

We can quickly profile the time each node takes in execution using the
modifier ``mmodel.modifier.profile_time``. 

Define the components and input parameters::

        from mrfmsim.component import SphereMagnet, Grid, Sample
        Sample(
        spin_type="electron",
        temperature=11.0,
        T1=1.3e-3,
        T2=0.45e-6,
        spin_density=0.0241,
    )
        magnet = SphereMagnet(radius=3300.0, mu0_Ms=440.0, origin=[0, 0, 3300])
        grid = Grid(shape=[400, 1200, 8], step=[25, 25, 25], origin=[0, 0, -100])

        B1 = 1.3e-3 # transverse magnetic field
        mw_x_0p = 100 # zero to peak amplitude of the cantilever motion [nm]
        B0_list = np.arange(500, 900, 200) # external field [mT]
        f_rf_list = np.arange(18.5e9, 19.5e9, 0.5e9) # microwave frequency [Hz]
        h = [0, 0, 1450]  # tip sample separation [nm]


Optimal looping
~~~~~~~~~~~~~~~~

In a lot of the MRFM experiments, we need to first calculate the field and
field gradient generated by the tip of the magnet. Depending on the size of
the simulation grid, this can be a very computationally intensive process.

If we want to simulate the change of the signal over a wide range of external
field (:math:`B_0`) and microwave frequency  (:math:`f_\mathrm{rf}``), we
would want to avoid repeated calculations of the tip field and gradient,
which are independent of the two parameters.

The graph-based experiment model can automatically determine the optimal loop
location and generate a new model with desired loops.

To loop the "f_rf" parameter::

    from mrfmsim.shortcut import loop_shortcut
    looped_cermitesr = loop_shortcut(cermitesr, "f_rf")
    looped_cermitesr.draw()

.. image:: _static/cermitesr_floop.pdf
    :width: 800px
    :align: center

To loop the "B0" parameter on top of f_rf::

    double_looped_cermitesr = loop_shortcut(looped_cermitesr, "B0")
    double_looped_cermitesr.draw()

.. image:: _static/cermitesr_bfloop.pdf
    :width: 800px
    :align: center

The model can be executed by supplying lists for "B0" and "f_rf"::

    result = double_looped_cermitesr(B0=B0_list, f_rf=f_rf_list)




