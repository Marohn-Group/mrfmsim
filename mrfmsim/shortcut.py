"""Shortcuts

The shortcut should work for both the Model and the Experiment classes.
"""

from mmodel import loop_input
from networkx.utils import nodes_equal
from mrfmsim.modifier import print_inputs, print_output
import networkx as nx


def print_shortcut(model, parameters, units={}, name=None):
    """Shortcut to printout parameters.

    The shortcuts determine if the parameter is an input parameter
    or an output parameter (intermediate value). If the parameter is
    intermediate value, the node that outputs the value adds the
    stdout_output_modifier, otherwise the input parameter output is
    at the level.
    """
    # use list comprehension instead of set to preserve order
    name = name or model.name
    input_params = []
    output_params = []
    for param in parameters:
        if param in model.__signature__.parameters:
            input_params.append(param)
        else:
            output_params.append(param)

    modifiers = model.modifiers
    G = model.graph  # produces a copy of the graph

    # input parameters modifier are the model level
    if input_params:
        mod = print_inputs(inputs=input_params, units=units)
        modifiers.append(mod)

    if output_params:
        # find the nodes with the output parameters
        for node, output in nx.get_node_attributes(G, "output").items():
            if output in output_params:
                mod = print_output(output=output, units=units)
                node_modifiers = G.nodes[node]["modifiers"]
                node_modifiers = node_modifiers + [mod]
                G.modify_node(node, modifiers=node_modifiers, inplace=True)

    return model.edit(name=name, graph=G, modifiers=modifiers)


def loop_shortcut(model, parameter: str, name=None):
    """Shortcut to add a loop to a subgraph.

    :param model: executable model
    :param str parameter: loop parameter
    :param str name: name of the new model, defaults to old model name.
    :return: a new model with looped parameter
    """
    # check if the parameter is in the signature
    if parameter not in model.__signature__.parameters:
        raise Exception(f"Invalid shortcut: {repr(parameter)} is not a model input.")

    G = model.graph
    name = name or model.name
    modifiers = model.modifiers

    loop_mod = loop_input(parameter)

    # If the parameter is in the signature but not in the graph.
    # This is due to the signature modifier on the model level
    # and the whole model is looped.

    if parameter not in G.signature.parameters:
        modifiers = [*modifiers, loop_mod]

    else:  # the parameter is within the graph
        H = G.subgraph(inputs=[parameter])

        if nodes_equal(G.nodes, H.nodes):
            modifiers = [*modifiers, loop_mod]

        elif len(H.nodes()) == 1:
            node = list(H.nodes)[0]
            # if the looped node is only one node
            # add loop modifier to node attribute
            node_modifiers = H.nodes[node]["modifiers"]
            node_modifiers = [*node_modifiers, loop_mod]
            G.modify_node(node, modifiers=node_modifiers, inplace=True)

        else:  # if there is more than one node
            sub_name = f"subnode_{parameter}"
            sub_des = (
                f"Submodel generated by loop_shortcut for parameter {repr(parameter)}."
            )
            output = ", ".join(H.returns)
            # create the model and substitute the subgraph
            looped_node = type(model)(
                f"submodel_{parameter}", H, model.handler, description=sub_des
            )

            G = G.replace_subgraph(
                H, sub_name, looped_node, output=output, modifiers=[loop_mod]
            )

    return model.edit(name=name, graph=G, modifiers=modifiers, **model.handler_args)
