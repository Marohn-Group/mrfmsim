"""Shortcuts

The shortcut should work for both the Model and the Experiment class8.
"""

from mmodel import loop_modifier
from networkx.utils import nodes_equal
from mrfmsim.modifier import stdout_input_modifier, stdout_output_modifier
import networkx as nx


def stdout_shortcut(model, parameters, units={}, name=None):
    """Shortcut to printout parameters.

    The shortcuts determine if the parameter is an input parameter
    or an output parameter (intermediate value). If the parameter is
    intermediate value, the node that outputs the value adds the
    stdout_output_modifier, otherwise the input parameter output is
    at the level.
    """
    # use list comprehension instead of set to preserve order
    name = name or model.name
    input_params = []
    output_params = []
    for param in parameters:
        if param in model.__signature__.parameters:
            input_params.append(param)
        else:
            output_params.append(param)

    modifiers = model.modifiers
    G = model.graph  # produces a copy of the graph

    # input parameters modifier are the model level
    if input_params:
        mod = (stdout_input_modifier, {"inputs": input_params, "units": units})
        modifiers.append(mod)

    if output_params:
        # find the nodes with the output parameters
        for node, output in nx.get_node_attributes(G, "output").items():
            if output in output_params:
                mod = (stdout_output_modifier, {"output": output, "units": units})
                node_modifiers = G.nodes[node]["modifiers"]
                node_modifiers.append(mod)
                G.modify_node(node, modifiers=node_modifiers, inplace=True)

    return type(model)(
        name=model.name,
        graph=G,
        handler=model.handler,
        modifiers=modifiers,
        description=model.description,
    )


def loop_shortcut(model, parameter: str, name=None):
    """Shortcut to add a loop to a subgraph.

    :param model: executable model
    :param str parameter: loop parameter
    :param str name: name of the new model, defaults to old model name.
    :return: a new model with looped parameter
    """
    # check if the parameter is in the signature
    if parameter not in model.__signature__.parameters:
        raise Exception(f"Invalid shortcut: {repr(parameter)} is not a model input.")

    G = model.graph
    name = name or model.name
    modifiers = model.modifiers

    loop_mod = (loop_modifier, {"parameter": parameter})
    # all process uses list unpack to create a new list!

    # this is the case when the parameter is in the signature but not in the graph
    # this is due to the signature modifier on the model level
    # therefore the whole model is looped.

    if parameter not in G.signature.parameters:
        modifiers = [*modifiers, loop_mod]

    else:  # the parameter is within the graph
        H = G.subgraph(inputs=[parameter])

        if nodes_equal(G.nodes, H.nodes):
            modifiers = [*modifiers, loop_mod]

        elif len(H.nodes()) == 1:
            node = list(H.nodes)[0]
            # if the looped node is only one node
            # add loop modifier to node attribute
            node_modifiers = H.nodes[node]["modifiers"]
            node_modifiers = [*node_modifiers, loop_mod]
            G.modify_node(node, modifiers=node_modifiers, inplace=True)

        else:  # if there is more than one node
            sub_name = f"subnode_{parameter}"
            sub_des = (
                f"Submodel generated by loop_shortcut for parameter {repr(parameter)}."
            )
            output = ", ".join(H.returns)
            # create the model and substitute the subgraph
            looped_node = type(model)(
                f"submodel_{parameter}", H, model.handler, description=sub_des
            )

            G = G.replace_subgraph(
                H, sub_name, looped_node, output=output, modifiers=[loop_mod]
            )

    return type(model)(
        name=name,
        graph=G,
        handler=model.handler,
        modifiers=modifiers,
        description=model.description,
    )


def remodel_shortcut(
    model,
    name=None,
    graph=None,
    handler=None,
    modifiers=None,
    description=None,
    returns=None,
):
    """Remodel parts of the model to generate a new model."""

    name = name or model.name
    graph = graph or model.graph
    # empty modifiers will skip if only use or statement
    modifiers = modifiers if not None else model.modifiers
    handler = handler or model.handler
    returns = returns if not None else model.returns
    description = description or model.description

    ModelCls = type(model)

    return ModelCls(
        name=name,
        graph=graph,
        handler=handler,
        modifiers=modifiers,
        description=description,
        returns=returns,
    )
