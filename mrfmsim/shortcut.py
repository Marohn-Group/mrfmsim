"""Shortcuts

The shortcut should work for both the Model and the Experiment classes.
"""

from mmodel.modifier import loop_input
from networkx.utils import nodes_equal
from mrfmsim.modifier import print_inputs, print_output
import networkx as nx


def print_shortcut(model, parameters, units={}, name=None):
    r"""Shortcut to printout parameters.

    If the parameter is a graph output value, we trace the output
    back to the last node (the last node in the topological sort
    of the subgraph). If the parameter is an input (or intermediate)
    input, we track the input to the first node (the first node in
    the topological sort). In the case that the input parameter
    shows up in two nodes, only one will be modified based on the
    topological sort.

    Sometimes multiple parameters are in one node, the algorithm
    will create multiple modifiers. The behavior is by design to
    simplify the algorithm.

    The printout of the input ends with ' | ' and the output ends
    with '\n'. The behavior is considered because normally user
    wants to print out outputs. The shortcut will not have line
    breaks if only input parameters are included.

    TODO

        Consider user customized format for the input and output.
    """
    # use list comprehension instead of set to preserve order
    name = name or model.name
    G = model.graph  # produces a copy of the graph

    for param in parameters:

        if param in G.returns:
            subgraph = G.subgraph(outputs=[param])
            node = list(nx.topological_sort(subgraph))[-1]
            mod = print_output(output=param, units=units, end="\n")
            node_modifiers = G.nodes[node]["modifiers"] + [mod]
            G.modify_node(node, modifiers=node_modifiers, inplace=True)

        else:
            subgraph = G.subgraph(inputs=[param])
            node = next(nx.topological_sort(subgraph))
            mod = print_inputs(inputs=[param], units=units, end=" | ")
            node_modifiers = G.nodes[node]["modifiers"] + [mod]
            G.modify_node(node, modifiers=node_modifiers, inplace=True)

    return model.edit(name=name, graph=G)


def loop_shortcut(model, parameter: str, name=None):
    """Shortcut to add a loop to a subgraph.

    :param model: executable model
    :param str parameter: loop parameter
    :param str name: name of the new model, defaults to old model name.
    :return: a new model with looped parameter
    """
    # check if the parameter is in the signature
    if parameter not in model.__signature__.parameters:
        raise Exception(f"Invalid shortcut: {repr(parameter)} is not a model input.")

    G = model.graph
    name = name or model.name
    modifiers = model.modifiers

    loop_mod = loop_input(parameter)

    # If the parameter is in the signature but not in the graph.
    # This is due to the signature modifier on the model level
    # and the whole model is looped.

    if parameter not in G.signature.parameters:
        modifiers = [*modifiers, loop_mod]

    else:  # the parameter is within the graph
        H = G.subgraph(inputs=[parameter])

        if nodes_equal(G.nodes, H.nodes):
            modifiers = [*modifiers, loop_mod]

        elif len(H.nodes()) == 1:
            node = list(H.nodes)[0]
            # if the looped node is only one node
            # add loop modifier to node attribute
            node_modifiers = H.nodes[node]["modifiers"]
            node_modifiers = [*node_modifiers, loop_mod]
            G.modify_node(node, modifiers=node_modifiers, inplace=True)

        else:  # if there is more than one node
            sub_name = f"subnode_{parameter}"
            sub_des = (
                f"Submodel generated by loop_shortcut for parameter {repr(parameter)}."
            )
            output = ", ".join(H.returns)
            # create the model and substitute the subgraph
            looped_node = type(model)(
                f"submodel_{parameter}", H, model.handler, description=sub_des
            )

            G = G.replace_subgraph(
                H, sub_name, looped_node, output=output, modifiers=[loop_mod]
            )

    return model.edit(name=name, graph=G, modifiers=modifiers, **model.handler_args)
